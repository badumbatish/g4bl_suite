{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the fermi_proj documentation site!</p> <p>The documentation site reflects the most recently changed (that is pushed) version of the project.</p> <p>This means that you are encouraged to reinstall to the next major version when it rolls out ASAP since there will not be any documentation online to reference again.</p> <p>Needs volunteers! Please please pleaseeee</p>"},{"location":"Automator.reference/","title":"Automator.py","text":""},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator","title":"<code>Automator</code>","text":"Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>class Automator:\n    def __init__(self):\n        self.cmd = None\n        self.file_name = None\n        self.params_dict = None\n\n    def set_cmd(self, cmd) -&gt; Automator:\n        self.cmd = cmd\n        return self\n\n    def set_params_dict(self, params_dict) -&gt; Automator:\n        self.params_dict = params_dict\n        return self\n\n    def set_file_name(self, file_name) -&gt; Automator:\n        self.file_name = file_name\n        return self\n\n    def is_g4bl(self) -&gt; bool:\n        \"\"\"\n        Check if a string representing a command ends in g4bl\n        Args:\n        Returns:\n            boolean\n\n        \"\"\"\n\n        return self.cmd.endswith(\"g4bl\")\n\n    def is_g4bl_mpi(self) -&gt; bool:\n        \"\"\"\n        Check if a string representing a command ends in g4blmpi\n        Args:\n        Returns:\n            boolean\n\n        \"\"\"\n        return self.cmd.endswith(\"g4blmpi\")\n\n    def generate_args(self, mpi_count=None) -&gt; List[List[str]]:\n        \"\"\"\n        Generates a list of arguments that is the first parameter for subprocess.run\n\n\n        Returns:\n            List A of list B of strings, where each list B is 1 config to pass to the command line via subprocess.run\n        \"\"\"\n\n        keys = []\n        values = []\n        for key, value in self.params_dict.items():\n            # Handle keys: Extend with elements if key is a tuple\n            # or add the key itself in form of a list if it's not a tuple\n            keys.extend(key if isinstance(key, tuple) else [key])\n\n            # Handle values: Append the value converted into a list if it's a tuple, otherwise append the value itself\n            values.append(list(value) if isinstance(value, tuple) else value)\n\n        # combinations = list(itertools.product(*param_dict.values()))\n\n        combinations = list(itertools.product(*values))\n\n        def flatten(a):\n            rt = []\n            for x in a:\n                if isinstance(x, list):\n                    rt.extend(flatten(x))\n                else:\n                    rt.append(x)\n            return rt\n\n        args = []\n        for combination in combinations:\n            lst = [self.cmd]\n            if self.is_g4bl_mpi():\n                lst.append(str(mpi_count))\n            lst.append(self.file_name)\n            combination = flatten(combination)\n            for i, value in enumerate(combination):\n                lst.append(f\"{keys[i]}={value}\")\n            args.append(lst)\n\n        return args\n\n    def tuple_zipl(self, args):\n        \"\"\"Return a tuple of list from the argument being a list of tuples\"\"\"\n        tp = []\n        for v in args:\n            v = list(v)\n            tp.append(v)\n        a = tuple(tp)\n        return a\n\n    def run_command(self, args):\n        \"\"\"\n        Helper function for automate()\n        \"\"\"\n        # print(f\"Running {args}\")\n        subprocess.run(args, stdout=subprocess.DEVNULL)\n\n    # TODO: Return a function that takes in a configuration of unknown type, and the list of arguments, then output\n    # a new list of that g4bl has never computed before,\n    # in order for g4bl to not waste computation, and the physicist to not die waiting\n\n    def automate(\n        self,\n        param_dict: dict = None,\n        file_name: str = None,\n        total_process_count=1,\n        mpi_count=None,\n        detector_lst=None,\n        data_directory=None,\n    ):\n        \"\"\"\n        Automating, automating, gaslighting, girlbossing, gatekeeping, mmm-kayyyy\n\n        Automate the search space/high parameter space with G4Beamline,\n        refers to the link of Automation in the Documentation page\n        Links:\n            https://badumbatish.github.io/fermi_proj/automation/\n        \"\"\"\n        if param_dict is None:\n            param_dict = self.params_dict\n        if file_name is None:\n            file_name = self.file_name\n\n        if (param_dict is None) or (file_name is None):\n            raise ValueError(\n                \"param_dict and file_name must be set either through automate() or set_params_dict() and set_file_name()\")\n        args = self.generate_args(str(mpi_count))\n\n        if not (data_directory is None):\n            args = self.skip_task_by_list(args, detector_lst, data_directory)\n\n        if mpi_count is None:\n            process_count = int(total_process_count)\n        else:\n            process_count = int(total_process_count / int(mpi_count))\n\n        print(\n            f\"Creating pool with total process count = {total_process_count},\"\n            f\"pool process count = \"\n            \"{process_count}, G4BLMPI process count = {mpi_count}\"\n        )\n        with mp.Pool(process_count) as p:\n            # color is pastel pink hehe\n            list(\n                tqdm.tqdm(\n                    p.imap_unordered(self.run_command, args),\n                    total=len(args),\n                    colour=\"#F8C8DC\",\n                    desc=\"Batch progress bar\",\n                )\n            )\n\n    def filter_args(self, arg_lists: List[List[str]]) -&gt; List[List[str]]:\n        \"\"\"\n        Filters each sublist in the input list of lists, returning only those strings\n        that follow the 'key=value' format.\n\n        Args:\n            arg_lists (List[List[str]]): A list of lists, where each sublist contains strings.\n\n        Returns:\n            List[List[str]]: A list of sublists containing strings formatted as 'key=value'.\n\n        Examples:\n        &gt;&gt;&gt; Automator().filter_args([[\"name=John\", \"age=30\"], [\"error\", \"size=medium\"]])\n        [['name=John', 'age=30'], ['size=medium']]\n\n        &gt;&gt;&gt; Automator().filter_args([[\"valid=100\", \"invalid\"], [], [\"key=value\", \"setting\"]])\n        [['valid=100'], ['key=value']]\n\n        &gt;&gt;&gt; Automator().filter_args([[\"123\", \"check=ok\"], [\"test=\", \"=data\"]])\n        [['check=ok']]\n        \"\"\"\n        result = []\n        for lst in arg_lists:\n            sub_list = [item for item in lst if 0 &lt;\n                        item.find(\"=\") &lt; len(item) - 1]\n            if len(sub_list) != 0:\n                result.append(sub_list)\n\n        return result\n\n    def construct_list_files(self, filtered_arg_list: list, postfix_string_list=None):\n        \"\"\"\n        Constructs a list (1) of lists (2) of lists (3), where lists (3) represents the files\n            that a batch outputs, lists (2) represents each command to the terminal.\n        This function essentially constructs a list of files from the argument list generated by generate_args()\n            and filtered via filter_args()\n        Check tests/unit_test/test_remembrance.py -&gt; test_construct_list_files()\n        \"\"\"\n        # Constructor list file\n\n        # if there is postfix_string_list, add to every filtered_arg_list\n\n        # Append .txt in the end\n\n        result = []\n        for lst in filtered_arg_list:\n            task_output_list = []\n            std_config = \"\"\n            for item in lst:\n                std_config = std_config + item.replace(\"=\", \"\")\n                std_config += \"|\"\n            std_config = std_config[: len(std_config) - 1]\n\n            if postfix_string_list is None:\n                task_output_list.append(std_config)\n            else:\n                for item in postfix_string_list:\n                    task_output_list.append(std_config + f\"|{item}\")\n            result.append(task_output_list)\n\n        def recursively_add_txt(items: list):\n            res = []\n            for temp_item in items:\n                if isinstance(temp_item, list):\n                    # Recurse if the item is a list\n                    res.append(recursively_add_txt(temp_item))\n                else:\n                    res.append(f\"{temp_item}.txt\")\n            return res\n\n        result = recursively_add_txt(result)\n        return result\n\n    def all_file_exists(self, data_list, data_directory=None, test=False) -&gt; bool:\n        \"\"\"\n        Returns:\n            A boolean value that returns True if all the files in data_list,\n             located in data_directory. It'll return false if one or more files is not present.\n\n\n        \"\"\"\n        all_files_exist = True\n\n        if test is True:\n            relative_dir_path = \"tests/unit/test_data/remembrance/\"\n            data_directory = os.path.join(os.getcwd(), relative_dir_path)\n\n        for data_file in data_list:\n            file_path = data_directory + data_file\n\n            if not exists(file_path):\n                print(f\"File not found: {file_path}\")\n                all_files_exist = False\n\n        return all_files_exist\n\n    def get_index_of_needed_tasks(\n        self, data_list, data_directory=None, test=False\n    ) -&gt; List[bool]:\n        \"\"\"\n        Determines which tasks need to be executed based on the existence of their associated data files.\n\n        Args:\n            data_list (List[str]): List of data file names or paths associated with tasks.\n            data_directory (str, optional): Directory to prepend to file names for existence checks. Defaults to None.\n            test (bool, optional): Indicates whether this function is being called in a test environment. Defaults to False.\n\n        Returns:\n            List[bool]: A list where each element is a boolean indicating\n            whether the task associated with the corresponding index in `data_files` needs to be executed\n            (True if it does not exist and False otherwise).\n        \"\"\"\n        # Determine the existence of each file\n        # and return the negation (True if file does not exist and hence task is needed)\n        return [\n            bool(self.all_file_exists(file, data_directory, test)) for file in data_list\n        ]\n\n    def skip_task_by_list(\n        self,\n        tasks: List[List[str]],\n        postfixes: List[str],\n        data_directory: str = None,\n        test: bool = False,\n    ) -&gt; List[List[str]]:\n        \"\"\"\n        Filters out tasks that have already been computed and returns a list of tasks still needing processing.\n\n        Args:\n            tasks (List[str]): List of task identifiers.\n            postfixes (List[str]): List of postfix strings used to check task completion.\n            data_directory (str, optional): Directory where task outputs are stored. Defaults to None.\n            test (bool, optional): Flag for test mode. Defaults to False.\n\n        Returns:\n            List[str]: List of tasks that have not yet been computed.\n        \"\"\"\n        filtered_args = self.filter_args(tasks)\n        task_files = self.construct_list_files(filtered_args, postfixes)\n        needed_task_indices = self.get_index_of_needed_tasks(\n            task_files, data_directory, test\n        )\n\n        # Select and return tasks that have not been completed yet\n        return [tasks[i] for i, needed in enumerate(needed_task_indices) if needed]\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.all_file_exists","title":"<code>all_file_exists(data_list, data_directory=None, test=False)</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>A boolean value that returns True if all the files in data_list, located in data_directory. It'll return false if one or more files is not present.</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def all_file_exists(self, data_list, data_directory=None, test=False) -&gt; bool:\n    \"\"\"\n    Returns:\n        A boolean value that returns True if all the files in data_list,\n         located in data_directory. It'll return false if one or more files is not present.\n\n\n    \"\"\"\n    all_files_exist = True\n\n    if test is True:\n        relative_dir_path = \"tests/unit/test_data/remembrance/\"\n        data_directory = os.path.join(os.getcwd(), relative_dir_path)\n\n    for data_file in data_list:\n        file_path = data_directory + data_file\n\n        if not exists(file_path):\n            print(f\"File not found: {file_path}\")\n            all_files_exist = False\n\n    return all_files_exist\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.automate","title":"<code>automate(param_dict=None, file_name=None, total_process_count=1, mpi_count=None, detector_lst=None, data_directory=None)</code>","text":"<p>Automating, automating, gaslighting, girlbossing, gatekeeping, mmm-kayyyy</p> <p>Automate the search space/high parameter space with G4Beamline, refers to the link of Automation in the Documentation page Links:     https://badumbatish.github.io/fermi_proj/automation/</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def automate(\n    self,\n    param_dict: dict = None,\n    file_name: str = None,\n    total_process_count=1,\n    mpi_count=None,\n    detector_lst=None,\n    data_directory=None,\n):\n    \"\"\"\n    Automating, automating, gaslighting, girlbossing, gatekeeping, mmm-kayyyy\n\n    Automate the search space/high parameter space with G4Beamline,\n    refers to the link of Automation in the Documentation page\n    Links:\n        https://badumbatish.github.io/fermi_proj/automation/\n    \"\"\"\n    if param_dict is None:\n        param_dict = self.params_dict\n    if file_name is None:\n        file_name = self.file_name\n\n    if (param_dict is None) or (file_name is None):\n        raise ValueError(\n            \"param_dict and file_name must be set either through automate() or set_params_dict() and set_file_name()\")\n    args = self.generate_args(str(mpi_count))\n\n    if not (data_directory is None):\n        args = self.skip_task_by_list(args, detector_lst, data_directory)\n\n    if mpi_count is None:\n        process_count = int(total_process_count)\n    else:\n        process_count = int(total_process_count / int(mpi_count))\n\n    print(\n        f\"Creating pool with total process count = {total_process_count},\"\n        f\"pool process count = \"\n        \"{process_count}, G4BLMPI process count = {mpi_count}\"\n    )\n    with mp.Pool(process_count) as p:\n        # color is pastel pink hehe\n        list(\n            tqdm.tqdm(\n                p.imap_unordered(self.run_command, args),\n                total=len(args),\n                colour=\"#F8C8DC\",\n                desc=\"Batch progress bar\",\n            )\n        )\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.construct_list_files","title":"<code>construct_list_files(filtered_arg_list, postfix_string_list=None)</code>","text":"<p>Constructs a list (1) of lists (2) of lists (3), where lists (3) represents the files     that a batch outputs, lists (2) represents each command to the terminal. This function essentially constructs a list of files from the argument list generated by generate_args()     and filtered via filter_args() Check tests/unit_test/test_remembrance.py -&gt; test_construct_list_files()</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def construct_list_files(self, filtered_arg_list: list, postfix_string_list=None):\n    \"\"\"\n    Constructs a list (1) of lists (2) of lists (3), where lists (3) represents the files\n        that a batch outputs, lists (2) represents each command to the terminal.\n    This function essentially constructs a list of files from the argument list generated by generate_args()\n        and filtered via filter_args()\n    Check tests/unit_test/test_remembrance.py -&gt; test_construct_list_files()\n    \"\"\"\n    # Constructor list file\n\n    # if there is postfix_string_list, add to every filtered_arg_list\n\n    # Append .txt in the end\n\n    result = []\n    for lst in filtered_arg_list:\n        task_output_list = []\n        std_config = \"\"\n        for item in lst:\n            std_config = std_config + item.replace(\"=\", \"\")\n            std_config += \"|\"\n        std_config = std_config[: len(std_config) - 1]\n\n        if postfix_string_list is None:\n            task_output_list.append(std_config)\n        else:\n            for item in postfix_string_list:\n                task_output_list.append(std_config + f\"|{item}\")\n        result.append(task_output_list)\n\n    def recursively_add_txt(items: list):\n        res = []\n        for temp_item in items:\n            if isinstance(temp_item, list):\n                # Recurse if the item is a list\n                res.append(recursively_add_txt(temp_item))\n            else:\n                res.append(f\"{temp_item}.txt\")\n        return res\n\n    result = recursively_add_txt(result)\n    return result\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.filter_args","title":"<code>filter_args(arg_lists)</code>","text":"<p>Filters each sublist in the input list of lists, returning only those strings that follow the 'key=value' format.</p> <p>Parameters:</p> Name Type Description Default <code>arg_lists</code> <code>List[List[str]]</code> <p>A list of lists, where each sublist contains strings.</p> required <p>Returns:</p> Type Description <code>List[List[str]]</code> <p>List[List[str]]: A list of sublists containing strings formatted as 'key=value'.</p> <p>Examples:</p> <p>Automator().filter_args([[\"name=John\", \"age=30\"], [\"error\", \"size=medium\"]]) [['name=John', 'age=30'], ['size=medium']]</p> <p>Automator().filter_args([[\"valid=100\", \"invalid\"], [], [\"key=value\", \"setting\"]]) [['valid=100'], ['key=value']]</p> <p>Automator().filter_args([[\"123\", \"check=ok\"], [\"test=\", \"=data\"]]) [['check=ok']]</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def filter_args(self, arg_lists: List[List[str]]) -&gt; List[List[str]]:\n    \"\"\"\n    Filters each sublist in the input list of lists, returning only those strings\n    that follow the 'key=value' format.\n\n    Args:\n        arg_lists (List[List[str]]): A list of lists, where each sublist contains strings.\n\n    Returns:\n        List[List[str]]: A list of sublists containing strings formatted as 'key=value'.\n\n    Examples:\n    &gt;&gt;&gt; Automator().filter_args([[\"name=John\", \"age=30\"], [\"error\", \"size=medium\"]])\n    [['name=John', 'age=30'], ['size=medium']]\n\n    &gt;&gt;&gt; Automator().filter_args([[\"valid=100\", \"invalid\"], [], [\"key=value\", \"setting\"]])\n    [['valid=100'], ['key=value']]\n\n    &gt;&gt;&gt; Automator().filter_args([[\"123\", \"check=ok\"], [\"test=\", \"=data\"]])\n    [['check=ok']]\n    \"\"\"\n    result = []\n    for lst in arg_lists:\n        sub_list = [item for item in lst if 0 &lt;\n                    item.find(\"=\") &lt; len(item) - 1]\n        if len(sub_list) != 0:\n            result.append(sub_list)\n\n    return result\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.generate_args","title":"<code>generate_args(mpi_count=None)</code>","text":"<p>Generates a list of arguments that is the first parameter for subprocess.run</p> <p>Returns:</p> Type Description <code>List[List[str]]</code> <p>List A of list B of strings, where each list B is 1 config to pass to the command line via subprocess.run</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def generate_args(self, mpi_count=None) -&gt; List[List[str]]:\n    \"\"\"\n    Generates a list of arguments that is the first parameter for subprocess.run\n\n\n    Returns:\n        List A of list B of strings, where each list B is 1 config to pass to the command line via subprocess.run\n    \"\"\"\n\n    keys = []\n    values = []\n    for key, value in self.params_dict.items():\n        # Handle keys: Extend with elements if key is a tuple\n        # or add the key itself in form of a list if it's not a tuple\n        keys.extend(key if isinstance(key, tuple) else [key])\n\n        # Handle values: Append the value converted into a list if it's a tuple, otherwise append the value itself\n        values.append(list(value) if isinstance(value, tuple) else value)\n\n    # combinations = list(itertools.product(*param_dict.values()))\n\n    combinations = list(itertools.product(*values))\n\n    def flatten(a):\n        rt = []\n        for x in a:\n            if isinstance(x, list):\n                rt.extend(flatten(x))\n            else:\n                rt.append(x)\n        return rt\n\n    args = []\n    for combination in combinations:\n        lst = [self.cmd]\n        if self.is_g4bl_mpi():\n            lst.append(str(mpi_count))\n        lst.append(self.file_name)\n        combination = flatten(combination)\n        for i, value in enumerate(combination):\n            lst.append(f\"{keys[i]}={value}\")\n        args.append(lst)\n\n    return args\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.get_index_of_needed_tasks","title":"<code>get_index_of_needed_tasks(data_list, data_directory=None, test=False)</code>","text":"<p>Determines which tasks need to be executed based on the existence of their associated data files.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[str]</code> <p>List of data file names or paths associated with tasks.</p> required <code>data_directory</code> <code>str</code> <p>Directory to prepend to file names for existence checks. Defaults to None.</p> <code>None</code> <code>test</code> <code>bool</code> <p>Indicates whether this function is being called in a test environment. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[bool]</code> <p>List[bool]: A list where each element is a boolean indicating</p> <code>List[bool]</code> <p>whether the task associated with the corresponding index in <code>data_files</code> needs to be executed</p> <code>List[bool]</code> <p>(True if it does not exist and False otherwise).</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def get_index_of_needed_tasks(\n    self, data_list, data_directory=None, test=False\n) -&gt; List[bool]:\n    \"\"\"\n    Determines which tasks need to be executed based on the existence of their associated data files.\n\n    Args:\n        data_list (List[str]): List of data file names or paths associated with tasks.\n        data_directory (str, optional): Directory to prepend to file names for existence checks. Defaults to None.\n        test (bool, optional): Indicates whether this function is being called in a test environment. Defaults to False.\n\n    Returns:\n        List[bool]: A list where each element is a boolean indicating\n        whether the task associated with the corresponding index in `data_files` needs to be executed\n        (True if it does not exist and False otherwise).\n    \"\"\"\n    # Determine the existence of each file\n    # and return the negation (True if file does not exist and hence task is needed)\n    return [\n        bool(self.all_file_exists(file, data_directory, test)) for file in data_list\n    ]\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.is_g4bl","title":"<code>is_g4bl()</code>","text":"<p>Check if a string representing a command ends in g4bl Args: Returns:     boolean</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def is_g4bl(self) -&gt; bool:\n    \"\"\"\n    Check if a string representing a command ends in g4bl\n    Args:\n    Returns:\n        boolean\n\n    \"\"\"\n\n    return self.cmd.endswith(\"g4bl\")\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.is_g4bl_mpi","title":"<code>is_g4bl_mpi()</code>","text":"<p>Check if a string representing a command ends in g4blmpi Args: Returns:     boolean</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def is_g4bl_mpi(self) -&gt; bool:\n    \"\"\"\n    Check if a string representing a command ends in g4blmpi\n    Args:\n    Returns:\n        boolean\n\n    \"\"\"\n    return self.cmd.endswith(\"g4blmpi\")\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.run_command","title":"<code>run_command(args)</code>","text":"<p>Helper function for automate()</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def run_command(self, args):\n    \"\"\"\n    Helper function for automate()\n    \"\"\"\n    # print(f\"Running {args}\")\n    subprocess.run(args, stdout=subprocess.DEVNULL)\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.skip_task_by_list","title":"<code>skip_task_by_list(tasks, postfixes, data_directory=None, test=False)</code>","text":"<p>Filters out tasks that have already been computed and returns a list of tasks still needing processing.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>List[str]</code> <p>List of task identifiers.</p> required <code>postfixes</code> <code>List[str]</code> <p>List of postfix strings used to check task completion.</p> required <code>data_directory</code> <code>str</code> <p>Directory where task outputs are stored. Defaults to None.</p> <code>None</code> <code>test</code> <code>bool</code> <p>Flag for test mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[List[str]]</code> <p>List[str]: List of tasks that have not yet been computed.</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def skip_task_by_list(\n    self,\n    tasks: List[List[str]],\n    postfixes: List[str],\n    data_directory: str = None,\n    test: bool = False,\n) -&gt; List[List[str]]:\n    \"\"\"\n    Filters out tasks that have already been computed and returns a list of tasks still needing processing.\n\n    Args:\n        tasks (List[str]): List of task identifiers.\n        postfixes (List[str]): List of postfix strings used to check task completion.\n        data_directory (str, optional): Directory where task outputs are stored. Defaults to None.\n        test (bool, optional): Flag for test mode. Defaults to False.\n\n    Returns:\n        List[str]: List of tasks that have not yet been computed.\n    \"\"\"\n    filtered_args = self.filter_args(tasks)\n    task_files = self.construct_list_files(filtered_args, postfixes)\n    needed_task_indices = self.get_index_of_needed_tasks(\n        task_files, data_directory, test\n    )\n\n    # Select and return tasks that have not been completed yet\n    return [tasks[i] for i, needed in enumerate(needed_task_indices) if needed]\n</code></pre>"},{"location":"Automator.reference/#src.g4bl_suite.Automator.Automator.tuple_zipl","title":"<code>tuple_zipl(args)</code>","text":"<p>Return a tuple of list from the argument being a list of tuples</p> Source code in <code>src/g4bl_suite/Automator.py</code> <pre><code>def tuple_zipl(self, args):\n    \"\"\"Return a tuple of list from the argument being a list of tuples\"\"\"\n    tp = []\n    for v in args:\n        v = list(v)\n        tp.append(v)\n    a = tuple(tp)\n    return a\n</code></pre>"},{"location":"DataAnalyzer.reference/","title":"DataAnalyzer.py","text":""},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.DataAnalyzer","title":"<code>DataAnalyzer</code>","text":"Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>class DataAnalyzer:\n    def __init__(self, file_name: str, **kwargs):\n        \"\"\"Constructs a 2D numpy array that formats just like\n        the output txt file from G4Beamline and raise exception if file does not exist\n\n        Args:\n            file_name:\n                str\n\n        Returns:\n            data:\n                a 2D numpy array\n        \"\"\"\n        if exists(file_name):\n            self.raw_data = np.genfromtxt(fname=file_name, **kwargs)\n            self.data = self.raw_data\n        else:\n            raise Exception(f\"The file {file_name} does not exist\")\n\n        if len(self.data.shape) == 1:\n\n            self.raw_data = self.raw_data[np.newaxis, :]\n            self.data = self.raw_data\n\n    def get_data(self) -&gt; np.ndarray:\n        return self.data\n\n    @staticmethod\n    def extract_particle_data(data, particle_name=None, particle_id=None):\n        \"\"\"Extracts a numpy array of only a certain particle out of a raw data\n\n        Args:\n\n        Returns:\n            A 2D numpy array containing only that singular particle data type\n\n        Raises:\n            An exception if there is no particle id or particle name\n        \"\"\"\n        # make a 1D array mask that returns true if the PID is satisfied\n        # [:,7] represents the column of PIDs\n        if particle_id is not None:\n            mask = data[:, feature_dict[\"PDGid\"]] == particle_id\n        elif particle_name is not None:\n            mask = data[:, feature_dict[\"PDGid\"]] == particle_dict[particle_name]\n        else:\n            raise Exception(f\"Particle id or particle name is not present\")\n\n        # pass the mask to the raw data to select the PID-satisfying rows, then : to select all the columns of that row\n        particle_data = data[mask, :]\n\n        return particle_data\n\n    @staticmethod\n    def particle_exists(data, particle_name=None, particle_id=None):\n        \"\"\"\n        Checks if a certain particle identified by its name or ID exists within the provided data.\n\n        Args:\n            data (np.ndarray): The numpy array containing the raw data.\n            particle_name (str, optional): The name of the particle to check. Default is None.\n            particle_id (int, optional): The ID of the particle to check. Default is None.\n\n        Returns:\n            bool: True if the particle exists in the data, False otherwise.\n\n        Raises:\n            ValueError: If both particle_id and particle_name are None.\n        \"\"\"\n        if particle_id is not None:\n            mask = data[:, feature_dict[\"PDGid\"]] == particle_id\n        elif particle_name is not None:\n            mask = data[:, feature_dict[\"PDGid\"]] == particle_dict[particle_name]\n        else:\n            raise ValueError(\"Both particle id and particle name cannot be None.\")\n\n        return np.any(mask)\n\n    @staticmethod\n    def get_feature(data, feature_name):\n        \"\"\"\n        Returns a 1D NumPy array that is the feature in the original 2D NumPy array\n\n        \"\"\"\n        return data[:, feature_dict[feature_name]]\n\n    @staticmethod\n    def get_x_angle(data):\n        \"\"\"\n        This function returns a 1D array consisting of xp = Px/Pz in milliradian\n\n        Uses numpy for its computation\n        \"\"\"\n\n        p_x = data[:, feature_dict[\"Px\"]]\n        p_z = data[:, feature_dict[\"Pz\"]]\n\n        return (p_x / p_z) * 1000\n\n    @staticmethod\n    def get_y_angle(data):\n        \"\"\"\n        This function returns a 1D array consisting of yp = Py/Pz in milliradian\n        \"\"\"\n        p_y = data[:, feature_dict[\"Py\"]]\n        p_z = data[:, feature_dict[\"Pz\"]]\n\n        return (p_y / p_z) * 1000\n\n    @staticmethod\n    def get_particle_count(data, particle_name=None, particle_id=None):\n        \"\"\"\n        Get the count of a particular particle\n\n        \"\"\"\n        if particle_id is not None:\n            res = np.count_nonzero(data[:, feature_dict[\"PDGid\"]] == particle_id)\n        elif particle_name is not None:\n            res = np.count_nonzero(\n                data[:, feature_dict[\"PDGid\"]] == particle_dict[particle_name]\n            )\n        else:\n            raise Exception(f\"Particle id or particle name is not present\")\n        return res\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.DataAnalyzer.__init__","title":"<code>__init__(file_name, **kwargs)</code>","text":"<p>Constructs a 2D numpy array that formats just like the output txt file from G4Beamline and raise exception if file does not exist</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>str</p> required <p>Returns:</p> Name Type Description <code>data</code> <p>a 2D numpy array</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>def __init__(self, file_name: str, **kwargs):\n    \"\"\"Constructs a 2D numpy array that formats just like\n    the output txt file from G4Beamline and raise exception if file does not exist\n\n    Args:\n        file_name:\n            str\n\n    Returns:\n        data:\n            a 2D numpy array\n    \"\"\"\n    if exists(file_name):\n        self.raw_data = np.genfromtxt(fname=file_name, **kwargs)\n        self.data = self.raw_data\n    else:\n        raise Exception(f\"The file {file_name} does not exist\")\n\n    if len(self.data.shape) == 1:\n\n        self.raw_data = self.raw_data[np.newaxis, :]\n        self.data = self.raw_data\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.DataAnalyzer.extract_particle_data","title":"<code>extract_particle_data(data, particle_name=None, particle_id=None)</code>  <code>staticmethod</code>","text":"<p>Extracts a numpy array of only a certain particle out of a raw data</p> <p>Args:</p> <p>Returns:</p> Type Description <p>A 2D numpy array containing only that singular particle data type</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>@staticmethod\ndef extract_particle_data(data, particle_name=None, particle_id=None):\n    \"\"\"Extracts a numpy array of only a certain particle out of a raw data\n\n    Args:\n\n    Returns:\n        A 2D numpy array containing only that singular particle data type\n\n    Raises:\n        An exception if there is no particle id or particle name\n    \"\"\"\n    # make a 1D array mask that returns true if the PID is satisfied\n    # [:,7] represents the column of PIDs\n    if particle_id is not None:\n        mask = data[:, feature_dict[\"PDGid\"]] == particle_id\n    elif particle_name is not None:\n        mask = data[:, feature_dict[\"PDGid\"]] == particle_dict[particle_name]\n    else:\n        raise Exception(f\"Particle id or particle name is not present\")\n\n    # pass the mask to the raw data to select the PID-satisfying rows, then : to select all the columns of that row\n    particle_data = data[mask, :]\n\n    return particle_data\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.DataAnalyzer.get_feature","title":"<code>get_feature(data, feature_name)</code>  <code>staticmethod</code>","text":"<p>Returns a 1D NumPy array that is the feature in the original 2D NumPy array</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>@staticmethod\ndef get_feature(data, feature_name):\n    \"\"\"\n    Returns a 1D NumPy array that is the feature in the original 2D NumPy array\n\n    \"\"\"\n    return data[:, feature_dict[feature_name]]\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.DataAnalyzer.get_particle_count","title":"<code>get_particle_count(data, particle_name=None, particle_id=None)</code>  <code>staticmethod</code>","text":"<p>Get the count of a particular particle</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>@staticmethod\ndef get_particle_count(data, particle_name=None, particle_id=None):\n    \"\"\"\n    Get the count of a particular particle\n\n    \"\"\"\n    if particle_id is not None:\n        res = np.count_nonzero(data[:, feature_dict[\"PDGid\"]] == particle_id)\n    elif particle_name is not None:\n        res = np.count_nonzero(\n            data[:, feature_dict[\"PDGid\"]] == particle_dict[particle_name]\n        )\n    else:\n        raise Exception(f\"Particle id or particle name is not present\")\n    return res\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.DataAnalyzer.get_x_angle","title":"<code>get_x_angle(data)</code>  <code>staticmethod</code>","text":"<p>This function returns a 1D array consisting of xp = Px/Pz in milliradian</p> <p>Uses numpy for its computation</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>@staticmethod\ndef get_x_angle(data):\n    \"\"\"\n    This function returns a 1D array consisting of xp = Px/Pz in milliradian\n\n    Uses numpy for its computation\n    \"\"\"\n\n    p_x = data[:, feature_dict[\"Px\"]]\n    p_z = data[:, feature_dict[\"Pz\"]]\n\n    return (p_x / p_z) * 1000\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.DataAnalyzer.get_y_angle","title":"<code>get_y_angle(data)</code>  <code>staticmethod</code>","text":"<p>This function returns a 1D array consisting of yp = Py/Pz in milliradian</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>@staticmethod\ndef get_y_angle(data):\n    \"\"\"\n    This function returns a 1D array consisting of yp = Py/Pz in milliradian\n    \"\"\"\n    p_y = data[:, feature_dict[\"Py\"]]\n    p_z = data[:, feature_dict[\"Pz\"]]\n\n    return (p_y / p_z) * 1000\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.DataAnalyzer.particle_exists","title":"<code>particle_exists(data, particle_name=None, particle_id=None)</code>  <code>staticmethod</code>","text":"<p>Checks if a certain particle identified by its name or ID exists within the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>The numpy array containing the raw data.</p> required <code>particle_name</code> <code>str</code> <p>The name of the particle to check. Default is None.</p> <code>None</code> <code>particle_id</code> <code>int</code> <p>The ID of the particle to check. Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the particle exists in the data, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both particle_id and particle_name are None.</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>@staticmethod\ndef particle_exists(data, particle_name=None, particle_id=None):\n    \"\"\"\n    Checks if a certain particle identified by its name or ID exists within the provided data.\n\n    Args:\n        data (np.ndarray): The numpy array containing the raw data.\n        particle_name (str, optional): The name of the particle to check. Default is None.\n        particle_id (int, optional): The ID of the particle to check. Default is None.\n\n    Returns:\n        bool: True if the particle exists in the data, False otherwise.\n\n    Raises:\n        ValueError: If both particle_id and particle_name are None.\n    \"\"\"\n    if particle_id is not None:\n        mask = data[:, feature_dict[\"PDGid\"]] == particle_id\n    elif particle_name is not None:\n        mask = data[:, feature_dict[\"PDGid\"]] == particle_dict[particle_name]\n    else:\n        raise ValueError(\"Both particle id and particle name cannot be None.\")\n\n    return np.any(mask)\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.hist_plot","title":"<code>hist_plot(axes, data, x_label='')</code>","text":"<pre><code>This function plots histogram in the axes\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>axes</code> <p>an axe plot</p> required <code>data</code> <p>a 1D numpy array</p> required <code>x_label</code> <code>str</code> <p>a string for x-label of the histogram plot</p> <code>''</code> <p>Returns:</p> Type Description <p>A histogram plot with extra descriptive data of count, mean, std, min, 25,50,75 percentile, and max.</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>def hist_plot(axes, data, x_label: str = \"\"):\n    \"\"\"\n        This function plots histogram in the axes\n\n    Args:\n        axes:\n            an axe plot\n        data:\n            a 1D numpy array\n        x_label:\n            a string for x-label of the histogram plot\n\n    Returns:\n        A histogram plot with extra descriptive data of count, mean, std, min, 25,50,75 percentile, and max.\n    ----------\n    \"\"\"\n    axes.hist(data)\n    if x_label == \"\":\n        axes.set_xlabel(x_label)\n        axes.set_ylabel(f\"Count of {x_label}\")\n    stats_str = (\n        f\"Count: {data.size}\\nMean: {data.mean():.3f}\\nStd: \"\n        f\"{data.std():.3f}\\nMin: {data.min()}\\n\"\n        f\"25%: {np.percentile(data, 25)}\\n50%: {np.percentile(data, 50)}\\n\"\n        f\"75%: {np.percentile(data, 75)}\\nMax: {data.max()}\"\n    )\n    axes.text(1.01, 0.2, stats_str, transform=plt.gca().transAxes)\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.save_figure","title":"<code>save_figure(fig, file_name, dpi=300)</code>","text":"<p>Save the figure into a file, usually pdf</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>def save_figure(fig, file_name, dpi=300):\n    \"\"\"Save the figure into a file, usually pdf\"\"\"\n    fig.set_size_inches((8.5, 11), forward=False)\n    fig.savefig(file_name, dpi=dpi)\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.scatter_plot","title":"<code>scatter_plot(axes, x_axis, y_axis, heat_map=False)</code>","text":"<p>Scatter plot an axes based on 2 1D numpy array</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <p>an object subplot from matplotlib that is an</p> required <code>x_axis</code> <p>1D array that denotes what to plot on the x-axis</p> required <code>y_axis</code> <p>1D array that denotes what to plot on the y-axis</p> required <code>heat_map</code> <p>A boolean, True if you want to use heat map, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <p>Function returns nothing, only plots a graph to the axes</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>def scatter_plot(axes, x_axis, y_axis, heat_map: bool = False):\n    \"\"\"Scatter plot an axes based on 2 1D numpy array\n\n    Args:\n        axes :\n            an object subplot from matplotlib that is an\n        x_axis :\n            1D array that denotes what to plot on the x-axis\n        y_axis :\n            1D array that denotes what to plot on the y-axis\n        heat_map :\n            A boolean, True if you want to use heat map, defaults to False\n\n    Returns:\n        Function returns nothing, only plots a graph to the axes\n    \"\"\"\n\n    if not heat_map:\n        axes.scatter(x_axis, y_axis, rasterized=False)\n    else:\n        density = axes.scatter_density(x_axis, y_axis)\n        plt.colorbar(density, ax=axes, label=\"Number of points per pixel\")\n</code></pre>"},{"location":"DataAnalyzer.reference/#src.g4bl_suite.DataAnalyzer.set_fig_misc","title":"<code>set_fig_misc(fig, beam_type, plot_type)</code>","text":"<p>Sets miscellaneous features of a figure</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> required <code>beam_type</code> required <code>plot_type</code> required <p>Returns:</p> Source code in <code>src/g4bl_suite/DataAnalyzer.py</code> <pre><code>def set_fig_misc(fig, beam_type, plot_type):\n    \"\"\"Sets miscellaneous features of a figure\n\n    Args:\n        fig :\n\n        beam_type :\n\n        plot_type :\n    Returns:\n    \"\"\"\n    fig.suptitle(f\"{beam_type.capitalize()} beam {plot_type}\")\n    fig.supxlabel(f\"x {plot_type}\")\n    fig.supylabel(f\"y {plot_type}\")\n</code></pre>"},{"location":"GlobalVariables.reference/","title":"Global Variables","text":""},{"location":"about/","title":"Welcome","text":""},{"location":"configuration/","title":"Configuration","text":"<p>Configuration data structure</p> <p>A list of strings where a valid of string is of type substr1=substr2 </p> <p>The algorithm will then replace the = in every valid string with $, then append all the modifed valid strings together, seperated by |  </p> <p>This requires the physicists to co-ordinates with g4beamline to help output the correct setup</p> <p>STEP 1: develop a function that takes in a list of strings representing files, and another list of string representing already existed files, return the index of only existed files.</p> <p>STEP 2: develop a function that takes in a list of strings of type substr1=substr2, returns a list of string substr1$substr2</p> <p>STEP 3: develop a function that takes in a list of strings, concatenate them into one single string of type string1|string2|string3.txt</p> <p>STEP 4: use step 2 function -&gt; step 3 function </p> <p>STEP 5: given a list of number representing indices, and a list of objects, select only the list of objects that is indices of the list </p>"},{"location":"development/","title":"Installation for developing the library","text":"<p> DO NOT DO THE FOLLOWING IF YOU ARE NOT DEVELOPING THE LIBRARY </p> <p>After you have clone the repository (or fork it), copy and paste the following code so  that dependencies can be installed.</p> <p>The code will install all the dependencies from <code>pyproject.toml</code></p> <pre><code>pip install -e .\n\n</code></pre>"},{"location":"installation/","title":"Installation for using the library","text":"<p> DO THE FOLLOWING IF YOU ARE USING THE LIBRARY </p> <p>Copy and paste the following code into your terminal.</p> <p>The code will install the library from the main branch of this repository.</p> <pre><code>pip install git+https://github.com/badumbatish/fermi_proj@main\n</code></pre>"},{"location":"installation/#installation-for-developing-the-library","title":"Installation for developing the library","text":"<p> DO NOT DO THE FOLLOWING IF YOU ARE NOT DEVELOPING THE LIBRARY </p> <p>After you have clone the repository (or fork it), copy and paste the following code so  that dependencies can be installed.</p> <p>The code will install all the dependencies from <code>pyproject.toml</code></p> <pre><code>pip install -e .\n\n</code></pre>"},{"location":"automation/","title":"Automation Documentation","text":"<p>This section instructs you how to use g4blplot.automate(). For installation instructions, refer to https://github.com/badumbatish/fermi_proj/ for documentation, including installation, general usage, development and others. Please open up a GitHub issue (and/or) a pull request for recommendation on updating this documentation.</p> <p>Ever wish you were able to tell your computer to parallel process different configurations of parameters of your G4Beamline file overnight so you can go to sleep peacefully and wake up with fresh data to process</p> <p>Just telling it: \"Hey hey hey, here are:\"</p> <ul> <li> <p>The full path of my g4bl command</p> </li> <li> <p>The g4bl file I want you to run</p> </li> <li> <p>A python dictionary that comprises of the parameters and lists (or tuples of lists) of their possible values.</p> </li> <li> <p>[Optional] The number of process I want my computer to spawn.</p> </li> <li> <p>[Optional] How many cores should each G4BLMPI batch run</p> </li> <li> <p>[Optional] The data directory you want automate to search and skip tasks on </p> </li> </ul> <p>Well, here comes</p> <pre><code>\ndef automate(cmd: str, param_dict: dict, file_name : str,total_process_count = 1, mpi_count = None, detector_lst=None, data_directory=None)\n\n</code></pre>"},{"location":"automation/#explanation","title":"Explanation","text":"<p>The automate() function uses run_command(), generate_args() as helper functions, and multiprocessing, itertools, and subprocess as its library.</p> <p>The helper function run_command() doesn't output anything to the terminal. It uses subprocess.run(args,stdout=subprocess.DEVNULL). Readers are advised to test out their g4bl file on low statistics first to make sure the file runs perfectly before using automate().</p> <p>The automate() function doesn't care for existing files as it doesn't know how a detector is named. It will run the commands, rewriting the files. Be advised not to waste computing energy by reruning automate() when dealing with high statistics computation on supercomputers.</p> <p>g4blplot.py now only supports the parallel processing part of the g4bl script, but not the data plotting and processing of all the output files generated by automate(). If more people desire the feature, maybe.</p> <p>For data processing of multiple files, users can use itertools.product() to output a list of lists of all combinations of parameters values, then they can use calculate the length of the list as a sufficient number of subplots and histogram plots and use for-loops to plots them using the functions of g4blplot</p>"},{"location":"automation/#set-up","title":"Set-up","text":""},{"location":"automation/#g4beamline-script-set-up","title":"G4beamline Script Set-up","text":""},{"location":"automation/#parameters","title":"Parameters","text":"<p>In this example</p> <ul> <li> <p>The parameter for the mean momentum is _meanMomentum</p> </li> <li> <p>The parameter for the mean angle of the x-axis is _meanXp</p> </li> </ul> <p>Start by adding -unset to all of your parameters in your .g4bl file.</p> <pre><code>param -unset _meanMomentum=100\nparam -unset _meanXp=0\n</code></pre>"},{"location":"automation/#detector-output","title":"Detector output","text":""},{"location":"automation/#ascii-formatting","title":"ASCII Formatting","text":"<p>Before:</p> <pre><code>virtualdetector Det radius=15.875 length=1 color=1,1,1 material=Vacuum\n</code></pre> <p>After:</p> <pre><code>virtualdetector Det radius=15.875 length=1 color=1,1,1 material=Vacuum format=ascii\n</code></pre>"},{"location":"automation/#output-file-renaming","title":"Output file renaming","text":"<p>Place a detector at some coordinate and include a rename command in the same line in the g4bl script</p> <p>The general (accepted by g4blplot.automate) format to format the output file name is </p> <pre><code>param1$_param1|param2$_param2|param3$_param3[|post_fix]\n</code></pre> <p>where [...] is optional</p> <p>The | is to separate different parameters.</p> <p>The $ is to reference the value of that parameters.</p> <p>For example:</p> <pre><code>place Det rename=_meanMomentum$_meanMomentum|_meanXp$_meanXp z=5921\n</code></pre>"},{"location":"automation/#python-script-set-up","title":"Python script Set-up","text":"<p>The script should start with</p> <pre><code>from g4bl_suite import Automator\n</code></pre> <p>Then the user should start by creating a parameter dictionary param_dict to feed it into g4blplot.automate()</p> <pre><code>\nparam_dict = {\n\n    \"_meanMomentum\": [100,200,300],\n\n    \"_meanXp\": [-0.4,-0.2,0,0.2,0.4]\n}\n\n</code></pre> <p>Check if the python process you are executing is main and execute the automate() function if true:</p> <pre><code>\nif __name__ == '__main__':\n\n    plot.automate(cmd = \"/Applications/G4beamline-3.08.app/Contents/MacOS/g4bl\",\n                    param_dict=param_dict,\n                    file_name = \"g4beamline_script/Pion_Line_BeamEllipse.g4bl\",\n                    total_process_count=4)\n</code></pre> <p>When you run this python program, below is its output, there should be a bar counting and update you on your computing progress (assuming you wrote the correct g4beamline script that you have tested already):</p> <p>Here we call the python file in the root directory, with one of its subdirectory is g4beamline_script</p> <pre><code>python3 src/main.py\nCreating pool with total process count = 4, pool process count = 4, G4BLMPI process count = None\n\nBatch progress bar: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 15/15 [00:03&lt;00:00, 4.89it/s]\n\n</code></pre> <p>You will have these files in the file directory that you run your g4bl command.</p> <pre><code>\njjsm@Jasmines-MacBook-Air fermi_proj % ls det*.txt\n\n_meanMomentum100|_meanXp-0.2.txt _meanMomentum100|_meanXp0.4.txt  _meanMomentum200|_meanXp-0.4.txt _meanMomentum200|_meanXp0.txt    _meanMomentum300|_meanXp0.2.txt\n_meanMomentum100|_meanXp-0.4.txt _meanMomentum100|_meanXp0.txt    _meanMomentum200|_meanXp0.2.txt  _meanMomentum300|_meanXp-0.2.txt _meanMomentum300|_meanXp0.4.txt\n_meanMomentum100|_meanXp0.2.txt  _meanMomentum200|_meanXp-0.2.txt _meanMomentum200|_meanXp0.4.txt  _meanMomentum300|_meanXp-0.4.txt _meanMomentum300|_meanXp0.txt\n\n\n</code></pre> <p>Here, we see that the g4beamline script outputs where we call the python script, not where the python script is located.</p> <p>We should then cd into a data directory and call the script from there</p> <p>End of documentation.</p>"},{"location":"dev/tools/","title":"TOOLS","text":""},{"location":"dev/tools/#type-hinting","title":"Type hinting","text":"<p>I use mypy for typechecking</p>"},{"location":"dev/tools/#formatter","title":"Formatter","text":"<p>I use black for formatting python code</p> <p>I use isort for formatting import </p>"},{"location":"dev/tools/#linting","title":"Linting","text":"<p>I use pylint for linting</p>"}]}